"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvaluateCloudFormationTemplate = exports.CfnEvaluationException = exports.LazyLookupExport = exports.LookupExportError = exports.LazyListStackResources = void 0;
class LazyListStackResources {
    constructor(sdk, stackName) {
        this.sdk = sdk;
        this.stackName = stackName;
    }
    async listStackResources() {
        if (this.stackResources === undefined) {
            this.stackResources = this.getStackResources(undefined);
        }
        return this.stackResources;
    }
    async getStackResources(nextToken) {
        const ret = new Array();
        return this.sdk.cloudFormation().listStackResources({
            StackName: this.stackName,
            NextToken: nextToken,
        }).promise().then(async (stackResourcesResponse) => {
            ret.push(...(stackResourcesResponse.StackResourceSummaries ?? []));
            if (stackResourcesResponse.NextToken) {
                ret.push(...await this.getStackResources(stackResourcesResponse.NextToken));
            }
            return ret;
        });
    }
}
exports.LazyListStackResources = LazyListStackResources;
class LookupExportError extends Error {
}
exports.LookupExportError = LookupExportError;
class LazyLookupExport {
    constructor(sdk) {
        this.sdk = sdk;
        this.cachedExports = {};
    }
    async lookupExport(name) {
        if (this.cachedExports[name]) {
            return this.cachedExports[name];
        }
        for await (const cfnExport of this.listExports()) {
            if (!cfnExport.Name) {
                continue; // ignore any result that omits a name
            }
            this.cachedExports[cfnExport.Name] = cfnExport;
            if (cfnExport.Name === name) {
                return cfnExport;
            }
        }
        return undefined; // export not found
    }
    async *listExports() {
        let nextToken = undefined;
        while (true) {
            const response = await this.sdk.cloudFormation().listExports({
                NextToken: nextToken,
            }).promise();
            for (const cfnExport of response.Exports ?? []) {
                yield cfnExport;
            }
            if (!response.NextToken) {
                return;
            }
            nextToken = response.NextToken;
        }
    }
}
exports.LazyLookupExport = LazyLookupExport;
class CfnEvaluationException extends Error {
}
exports.CfnEvaluationException = CfnEvaluationException;
class EvaluateCloudFormationTemplate {
    constructor(props) {
        this.stackName = props.stackName;
        this.template = props.template;
        this.context = {
            'AWS::AccountId': props.account,
            'AWS::Region': props.region,
            'AWS::Partition': props.partition,
            ...props.parameters,
        };
        this.account = props.account;
        this.region = props.region;
        this.partition = props.partition;
        this.urlSuffix = props.urlSuffix;
        this.sdk = props.sdk;
        // We need names of nested stack so we can evaluate cross stack references
        this.nestedStackNames = props.nestedStackNames ?? {};
        // The current resources of the Stack.
        // We need them to figure out the physical name of a resource in case it wasn't specified by the user.
        // We fetch it lazily, to save a service call, in case all hotswapped resources have their physical names set.
        this.stackResources = new LazyListStackResources(this.sdk, this.stackName);
        // CloudFormation Exports lookup to be able to resolve Fn::ImportValue intrinsics in template
        this.lookupExport = new LazyLookupExport(this.sdk);
    }
    // clones current EvaluateCloudFormationTemplate object, but updates the stack name
    async createNestedEvaluateCloudFormationTemplate(stackName, nestedTemplate, nestedStackParameters) {
        const evaluatedParams = await this.evaluateCfnExpression(nestedStackParameters);
        return new EvaluateCloudFormationTemplate({
            stackName,
            template: nestedTemplate,
            parameters: evaluatedParams,
            account: this.account,
            region: this.region,
            partition: this.partition,
            urlSuffix: this.urlSuffix,
            sdk: this.sdk,
            nestedStackNames: this.nestedStackNames,
        });
    }
    async establishResourcePhysicalName(logicalId, physicalNameInCfnTemplate) {
        if (physicalNameInCfnTemplate != null) {
            try {
                return await this.evaluateCfnExpression(physicalNameInCfnTemplate);
            }
            catch (e) {
                // If we can't evaluate the resource's name CloudFormation expression,
                // just look it up in the currently deployed Stack
                if (!(e instanceof CfnEvaluationException)) {
                    throw e;
                }
            }
        }
        return this.findPhysicalNameFor(logicalId);
    }
    async findPhysicalNameFor(logicalId) {
        const stackResources = await this.stackResources.listStackResources();
        return stackResources.find(sr => sr.LogicalResourceId === logicalId)?.PhysicalResourceId;
    }
    async findLogicalIdForPhysicalName(physicalName) {
        const stackResources = await this.stackResources.listStackResources();
        return stackResources.find(sr => sr.PhysicalResourceId === physicalName)?.LogicalResourceId;
    }
    findReferencesTo(logicalId) {
        const ret = new Array();
        for (const [resourceLogicalId, resourceDef] of Object.entries(this.template?.Resources ?? {})) {
            if (logicalId !== resourceLogicalId && this.references(logicalId, resourceDef)) {
                ret.push({
                    ...resourceDef,
                    LogicalId: resourceLogicalId,
                });
            }
        }
        return ret;
    }
    async evaluateCfnExpression(cfnExpression) {
        const self = this;
        /**
         * Evaluates CloudFormation intrinsic functions
         *
         * Note that supported intrinsic functions are documented in README.md -- please update
         * list of supported functions when adding new evaluations
         *
         * See: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html
         */
        class CfnIntrinsics {
            evaluateIntrinsic(intrinsic) {
                const intrinsicFunc = this[intrinsic.name];
                if (!intrinsicFunc) {
                    throw new CfnEvaluationException(`CloudFormation function ${intrinsic.name} is not supported`);
                }
                const argsAsArray = Array.isArray(intrinsic.args) ? intrinsic.args : [intrinsic.args];
                return intrinsicFunc.apply(this, argsAsArray);
            }
            async 'Fn::Join'(separator, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs.join(separator);
            }
            async 'Fn::Split'(separator, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs.split(separator);
            }
            async 'Fn::Select'(index, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs[index];
            }
            async 'Ref'(logicalId) {
                const refTarget = await self.findRefTarget(logicalId);
                if (refTarget) {
                    return refTarget;
                }
                else {
                    throw new CfnEvaluationException(`Parameter or resource '${logicalId}' could not be found for evaluation`);
                }
            }
            async 'Fn::GetAtt'(logicalId, attributeName) {
                // ToDo handle the 'logicalId.attributeName' form of Fn::GetAtt
                const attrValue = await self.findGetAttTarget(logicalId, attributeName);
                if (attrValue) {
                    return attrValue;
                }
                else {
                    throw new CfnEvaluationException(`Attribute '${attributeName}' of resource '${logicalId}' could not be found for evaluation`);
                }
            }
            async 'Fn::Sub'(template, explicitPlaceholders) {
                const placeholders = explicitPlaceholders
                    ? await self.evaluateCfnExpression(explicitPlaceholders)
                    : {};
                return asyncGlobalReplace(template, /\${([^}]*)}/g, key => {
                    if (key in placeholders) {
                        return placeholders[key];
                    }
                    else {
                        const splitKey = key.split('.');
                        return splitKey.length === 1
                            ? this.Ref(key)
                            : this['Fn::GetAtt'](splitKey[0], splitKey.slice(1).join('.'));
                    }
                });
            }
            async 'Fn::ImportValue'(name) {
                const exported = await self.lookupExport.lookupExport(name);
                if (!exported) {
                    throw new CfnEvaluationException(`Export '${name}' could not be found for evaluation`);
                }
                if (!exported.Value) {
                    throw new CfnEvaluationException(`Export '${name}' exists without a value`);
                }
                return exported.Value;
            }
        }
        if (cfnExpression == null) {
            return cfnExpression;
        }
        if (Array.isArray(cfnExpression)) {
            return Promise.all(cfnExpression.map(expr => this.evaluateCfnExpression(expr)));
        }
        if (typeof cfnExpression === 'object') {
            const intrinsic = this.parseIntrinsic(cfnExpression);
            if (intrinsic) {
                return new CfnIntrinsics().evaluateIntrinsic(intrinsic);
            }
            else {
                const ret = {};
                for (const [key, val] of Object.entries(cfnExpression)) {
                    ret[key] = await this.evaluateCfnExpression(val);
                }
                return ret;
            }
        }
        return cfnExpression;
    }
    references(logicalId, templateElement) {
        if (typeof templateElement === 'string') {
            return logicalId === templateElement;
        }
        if (templateElement == null) {
            return false;
        }
        if (Array.isArray(templateElement)) {
            return templateElement.some(el => this.references(logicalId, el));
        }
        if (typeof templateElement === 'object') {
            return Object.values(templateElement).some(el => this.references(logicalId, el));
        }
        return false;
    }
    parseIntrinsic(x) {
        const keys = Object.keys(x);
        if (keys.length === 1 && (keys[0].startsWith('Fn::') || keys[0] === 'Ref')) {
            return {
                name: keys[0],
                args: x[keys[0]],
            };
        }
        return undefined;
    }
    async findRefTarget(logicalId) {
        // first, check to see if the Ref is a Parameter who's value we have
        if (logicalId === 'AWS::URLSuffix') {
            if (!this.cachedUrlSuffix) {
                this.cachedUrlSuffix = this.urlSuffix(this.region);
            }
            return this.cachedUrlSuffix;
        }
        // Try finding the ref in the passed in parameters
        const parameterTarget = this.context[logicalId];
        if (parameterTarget) {
            return parameterTarget;
        }
        // If not in the passed in parameters, see if there is a default value in the template parameter that was not passed in
        const defaultParameterValue = this.template.Parameters?.[logicalId]?.Default;
        if (defaultParameterValue) {
            return defaultParameterValue;
        }
        // if it's not a Parameter, we need to search in the current Stack resources
        return this.findGetAttTarget(logicalId);
    }
    async findGetAttTarget(logicalId, attribute) {
        // Handle case where the attribute is referencing a stack output (used in nested stacks to share parameters)
        // See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-cloudformation.html#w2ab1c17c23c19b5
        if (logicalId === 'Outputs' && attribute) {
            return this.evaluateCfnExpression(this.template.Outputs[attribute]?.Value);
        }
        const stackResources = await this.stackResources.listStackResources();
        const foundResource = stackResources.find(sr => sr.LogicalResourceId === logicalId);
        if (!foundResource) {
            return undefined;
        }
        if (foundResource.ResourceType == 'AWS::CloudFormation::Stack' && attribute?.startsWith('Outputs.')) {
            // need to resolve attributes from another stack's Output section
            const dependantStackName = this.nestedStackNames[logicalId]?.nestedStackPhysicalName;
            if (!dependantStackName) {
                //this is a newly created nested stack and cannot be hotswapped
                return undefined;
            }
            const dependantStackTemplate = this.template.Resources[logicalId];
            const evaluateCfnTemplate = await this.createNestedEvaluateCloudFormationTemplate(dependantStackName, dependantStackTemplate?.Properties?.NestedTemplate, dependantStackTemplate.newValue?.Properties?.Parameters);
            // Split Outputs.<refName> into 'Outputs' and '<refName>' and recursively call evaluate
            return evaluateCfnTemplate.evaluateCfnExpression({ 'Fn::GetAtt': attribute.split(/\.(.*)/s) });
        }
        // now, we need to format the appropriate identifier depending on the resource type,
        // and the requested attribute name
        return this.formatResourceAttribute(foundResource, attribute);
    }
    formatResourceAttribute(resource, attribute) {
        const physicalId = resource.PhysicalResourceId;
        // no attribute means Ref expression, for which we use the physical ID directly
        if (!attribute) {
            return physicalId;
        }
        const resourceTypeFormats = RESOURCE_TYPE_ATTRIBUTES_FORMATS[resource.ResourceType];
        if (!resourceTypeFormats) {
            throw new CfnEvaluationException(`We don't support attributes of the '${resource.ResourceType}' resource. This is a CDK limitation. ` +
                'Please report it at https://github.com/aws/aws-cdk/issues/new/choose');
        }
        const attributeFmtFunc = resourceTypeFormats[attribute];
        if (!attributeFmtFunc) {
            throw new CfnEvaluationException(`We don't support the '${attribute}' attribute of the '${resource.ResourceType}' resource. This is a CDK limitation. ` +
                'Please report it at https://github.com/aws/aws-cdk/issues/new/choose');
        }
        const service = this.getServiceOfResource(resource);
        const resourceTypeArnPart = this.getResourceTypeArnPartOfResource(resource);
        return attributeFmtFunc({
            partition: this.partition,
            service,
            region: this.region,
            account: this.account,
            resourceType: resourceTypeArnPart,
            resourceName: physicalId,
        });
    }
    getServiceOfResource(resource) {
        return resource.ResourceType.split('::')[1].toLowerCase();
    }
    getResourceTypeArnPartOfResource(resource) {
        const resourceType = resource.ResourceType;
        const specialCaseResourceType = RESOURCE_TYPE_SPECIAL_NAMES[resourceType]?.resourceType;
        return specialCaseResourceType
            ? specialCaseResourceType
            // this is the default case
            : resourceType.split('::')[2].toLowerCase();
    }
}
exports.EvaluateCloudFormationTemplate = EvaluateCloudFormationTemplate;
/**
 * Usually, we deduce the names of the service and the resource type used to format the ARN from the CloudFormation resource type.
 * For a CFN type like AWS::Service::ResourceType, the second segment becomes the service name, and the third the resource type
 * (after converting both of them to lowercase).
 * However, some resource types break this simple convention, and we need to special-case them.
 * This map is for storing those cases.
 */
const RESOURCE_TYPE_SPECIAL_NAMES = {
    'AWS::Events::EventBus': {
        resourceType: 'event-bus',
    },
};
const RESOURCE_TYPE_ATTRIBUTES_FORMATS = {
    'AWS::IAM::Role': { Arn: iamArnFmt },
    'AWS::IAM::User': { Arn: iamArnFmt },
    'AWS::IAM::Group': { Arn: iamArnFmt },
    'AWS::S3::Bucket': { Arn: s3ArnFmt },
    'AWS::Lambda::Function': { Arn: stdColonResourceArnFmt },
    'AWS::Events::EventBus': {
        Arn: stdSlashResourceArnFmt,
        // the name attribute of the EventBus is the same as the Ref
        Name: parts => parts.resourceName,
    },
    'AWS::DynamoDB::Table': { Arn: stdSlashResourceArnFmt },
    'AWS::AppSync::GraphQLApi': { ApiId: appsyncGraphQlApiApiIdFmt },
    'AWS::AppSync::FunctionConfiguration': { FunctionId: appsyncGraphQlFunctionIDFmt },
    'AWS::AppSync::DataSource': { Name: appsyncGraphQlDataSourceNameFmt },
};
function iamArnFmt(parts) {
    // we skip region for IAM resources
    return `arn:${parts.partition}:${parts.service}::${parts.account}:${parts.resourceType}/${parts.resourceName}`;
}
function s3ArnFmt(parts) {
    // we skip account, region and resourceType for S3 resources
    return `arn:${parts.partition}:${parts.service}:::${parts.resourceName}`;
}
function stdColonResourceArnFmt(parts) {
    // this is a standard format for ARNs like: arn:aws:service:region:account:resourceType:resourceName
    return `arn:${parts.partition}:${parts.service}:${parts.region}:${parts.account}:${parts.resourceType}:${parts.resourceName}`;
}
function stdSlashResourceArnFmt(parts) {
    // this is a standard format for ARNs like: arn:aws:service:region:account:resourceType/resourceName
    return `arn:${parts.partition}:${parts.service}:${parts.region}:${parts.account}:${parts.resourceType}/${parts.resourceName}`;
}
function appsyncGraphQlApiApiIdFmt(parts) {
    // arn:aws:appsync:us-east-1:111111111111:apis/<apiId>
    return parts.resourceName.split('/')[1];
}
function appsyncGraphQlFunctionIDFmt(parts) {
    // arn:aws:appsync:us-east-1:111111111111:apis/<apiId>/functions/<functionId>
    return parts.resourceName.split('/')[3];
}
function appsyncGraphQlDataSourceNameFmt(parts) {
    // arn:aws:appsync:us-east-1:111111111111:apis/<apiId>/datasources/<name>
    return parts.resourceName.split('/')[3];
}
async function asyncGlobalReplace(str, regex, cb) {
    if (!regex.global) {
        throw new Error('Regex must be created with /g flag');
    }
    const ret = new Array();
    let start = 0;
    while (true) {
        const match = regex.exec(str);
        if (!match) {
            break;
        }
        ret.push(str.substring(start, match.index));
        ret.push(await cb(match[1]));
        start = regex.lastIndex;
    }
    ret.push(str.slice(start));
    return ret.join('');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFTQSxNQUFhLHNCQUFzQjtJQUdqQyxZQUE2QixHQUFTLEVBQW1CLFNBQWlCO1FBQTdDLFFBQUcsR0FBSCxHQUFHLENBQU07UUFBbUIsY0FBUyxHQUFULFNBQVMsQ0FBUTtJQUMxRSxDQUFDO0lBRU0sS0FBSyxDQUFDLGtCQUFrQjtRQUM3QixJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssU0FBUyxFQUFFO1lBQ3JDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3pEO1FBQ0QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdCLENBQUM7SUFFTyxLQUFLLENBQUMsaUJBQWlCLENBQUMsU0FBNkI7UUFDM0QsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQTJDLENBQUM7UUFDakUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDLGtCQUFrQixDQUFDO1lBQ2xELFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN6QixTQUFTLEVBQUUsU0FBUztTQUNyQixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBQyxzQkFBc0IsRUFBQyxFQUFFO1lBQy9DLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLHNCQUFzQixJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkUsSUFBSSxzQkFBc0IsQ0FBQyxTQUFTLEVBQUU7Z0JBQ3BDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2FBQzdFO1lBQ0Qs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b3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgUHJvbWlzZVJlc3VsdCB9IGZyb20gJ2F3cy1zZGsvbGliL3JlcXVlc3QnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgTmVzdGVkU3RhY2tOYW1lcyB9IGZyb20gJy4vbmVzdGVkLXN0YWNrLWhlbHBlcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RTdGFja1Jlc291cmNlcyB7XG4gIGxpc3RTdGFja1Jlc291cmNlcygpOiBQcm9taXNlPEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeVtdPjtcbn1cblxuZXhwb3J0IGNsYXNzIExhenlMaXN0U3RhY2tSZXNvdXJjZXMgaW1wbGVtZW50cyBMaXN0U3RhY2tSZXNvdXJjZXMge1xuICBwcml2YXRlIHN0YWNrUmVzb3VyY2VzOiBQcm9taXNlPEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeVtdPiB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHNkazogSVNESywgcHJpdmF0ZSByZWFkb25seSBzdGFja05hbWU6IHN0cmluZykge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGxpc3RTdGFja1Jlc291cmNlcygpOiBQcm9taXNlPEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeVtdPiB7XG4gICAgaWYgKHRoaXMuc3RhY2tSZXNvdXJjZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGFja1Jlc291cmNlcyA9IHRoaXMuZ2V0U3RhY2tSZXNvdXJjZXModW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tSZXNvdXJjZXM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFN0YWNrUmVzb3VyY2VzKG5leHRUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2tSZXNvdXJjZVN1bW1hcnlbXT4ge1xuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheTxBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2tSZXNvdXJjZVN1bW1hcnk+KCk7XG4gICAgcmV0dXJuIHRoaXMuc2RrLmNsb3VkRm9ybWF0aW9uKCkubGlzdFN0YWNrUmVzb3VyY2VzKHtcbiAgICAgIFN0YWNrTmFtZTogdGhpcy5zdGFja05hbWUsXG4gICAgICBOZXh0VG9rZW46IG5leHRUb2tlbixcbiAgICB9KS5wcm9taXNlKCkudGhlbihhc3luYyBzdGFja1Jlc291cmNlc1Jlc3BvbnNlID0+IHtcbiAgICAgIHJldC5wdXNoKC4uLihzdGFja1Jlc291cmNlc1Jlc3BvbnNlLlN0YWNrUmVzb3VyY2VTdW1tYXJpZXMgPz8gW10pKTtcbiAgICAgIGlmIChzdGFja1Jlc291cmNlc1Jlc3BvbnNlLk5leHRUb2tlbikge1xuICAgICAgICByZXQucHVzaCguLi5hd2FpdCB0aGlzLmdldFN0YWNrUmVzb3VyY2VzKHN0YWNrUmVzb3VyY2VzUmVzcG9uc2UuTmV4dFRva2VuKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9va3VwRXhwb3J0IHtcbiAgbG9va3VwRXhwb3J0KG5hbWU6IHN0cmluZyk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uLkV4cG9ydCB8IHVuZGVmaW5lZD47XG59XG5cbmV4cG9ydCBjbGFzcyBMb29rdXBFeHBvcnRFcnJvciBleHRlbmRzIEVycm9yIHsgfVxuXG5leHBvcnQgY2xhc3MgTGF6eUxvb2t1cEV4cG9ydCBpbXBsZW1lbnRzIExvb2t1cEV4cG9ydCB7XG4gIHByaXZhdGUgY2FjaGVkRXhwb3J0czogeyBbbmFtZTogc3RyaW5nXTogQVdTLkNsb3VkRm9ybWF0aW9uLkV4cG9ydCB9ID0ge31cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHNkazogSVNESykgeyB9XG5cbiAgYXN5bmMgbG9va3VwRXhwb3J0KG5hbWU6IHN0cmluZyk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uLkV4cG9ydCB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICh0aGlzLmNhY2hlZEV4cG9ydHNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlZEV4cG9ydHNbbmFtZV07XG4gICAgfVxuXG4gICAgZm9yIGF3YWl0IChjb25zdCBjZm5FeHBvcnQgb2YgdGhpcy5saXN0RXhwb3J0cygpKSB7XG4gICAgICBpZiAoIWNmbkV4cG9ydC5OYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBpZ25vcmUgYW55IHJlc3VsdCB0aGF0IG9taXRzIGEgbmFtZVxuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZWRFeHBvcnRzW2NmbkV4cG9ydC5OYW1lXSA9IGNmbkV4cG9ydDtcblxuICAgICAgaWYgKGNmbkV4cG9ydC5OYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBjZm5FeHBvcnQ7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBleHBvcnQgbm90IGZvdW5kXG4gIH1cblxuICBwcml2YXRlIGFzeW5jICogbGlzdEV4cG9ydHMoKSB7XG4gICAgbGV0IG5leHRUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCByZXNwb25zZTogUHJvbWlzZVJlc3VsdDxBV1MuQ2xvdWRGb3JtYXRpb24uTGlzdEV4cG9ydHNPdXRwdXQsIEFXUy5BV1NFcnJvcj4gPSBhd2FpdCB0aGlzLnNkay5jbG91ZEZvcm1hdGlvbigpLmxpc3RFeHBvcnRzKHtcbiAgICAgICAgTmV4dFRva2VuOiBuZXh0VG9rZW4sXG4gICAgICB9KS5wcm9taXNlKCk7XG5cbiAgICAgIGZvciAoY29uc3QgY2ZuRXhwb3J0IG9mIHJlc3BvbnNlLkV4cG9ydHMgPz8gW10pIHtcbiAgICAgICAgeWllbGQgY2ZuRXhwb3J0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLk5leHRUb2tlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXh0VG9rZW4gPSByZXNwb25zZS5OZXh0VG9rZW47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3IgeyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VEZWZpbml0aW9uIHtcbiAgcmVhZG9ubHkgTG9naWNhbElkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IFR5cGU6IHN0cmluZztcbiAgcmVhZG9ubHkgUHJvcGVydGllczogeyBbcDogc3RyaW5nXTogYW55IH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlUHJvcHMge1xuICByZWFkb25seSBzdGFja05hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgdGVtcGxhdGU6IFRlbXBsYXRlO1xuICByZWFkb25seSBwYXJhbWV0ZXJzOiB7IFtwYXJhbWV0ZXJOYW1lOiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgcmVhZG9ubHkgYWNjb3VudDogc3RyaW5nO1xuICByZWFkb25seSByZWdpb246IHN0cmluZztcbiAgcmVhZG9ubHkgcGFydGl0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHVybFN1ZmZpeDogKHJlZ2lvbjogc3RyaW5nKSA9PiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNkazogSVNESztcbiAgcmVhZG9ubHkgbmVzdGVkU3RhY2tOYW1lcz86IHsgW25lc3RlZFN0YWNrTG9naWNhbElkOiBzdHJpbmddOiBOZXN0ZWRTdGFja05hbWVzIH07XG59XG5cbmV4cG9ydCBjbGFzcyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUge1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHRlbXBsYXRlOiBUZW1wbGF0ZTtcbiAgcHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiB7IFtrOiBzdHJpbmddOiBhbnkgfTtcbiAgcHJpdmF0ZSByZWFkb25seSBhY2NvdW50OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVnaW9uOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcGFydGl0aW9uOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgdXJsU3VmZml4OiAocmVnaW9uOiBzdHJpbmcpID0+IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBzZGs6IElTREs7XG4gIHByaXZhdGUgcmVhZG9ubHkgbmVzdGVkU3RhY2tOYW1lczogeyBbbmVzdGVkU3RhY2tMb2dpY2FsSWQ6IHN0cmluZ106IE5lc3RlZFN0YWNrTmFtZXMgfTtcbiAgcHJpdmF0ZSByZWFkb25seSBzdGFja1Jlc291cmNlczogTGlzdFN0YWNrUmVzb3VyY2VzO1xuICBwcml2YXRlIHJlYWRvbmx5IGxvb2t1cEV4cG9ydDogTG9va3VwRXhwb3J0O1xuXG4gIHByaXZhdGUgY2FjaGVkVXJsU3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZVByb3BzKSB7XG4gICAgdGhpcy5zdGFja05hbWUgPSBwcm9wcy5zdGFja05hbWU7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IHByb3BzLnRlbXBsYXRlO1xuICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgICdBV1M6OkFjY291bnRJZCc6IHByb3BzLmFjY291bnQsXG4gICAgICAnQVdTOjpSZWdpb24nOiBwcm9wcy5yZWdpb24sXG4gICAgICAnQVdTOjpQYXJ0aXRpb24nOiBwcm9wcy5wYXJ0aXRpb24sXG4gICAgICAuLi5wcm9wcy5wYXJhbWV0ZXJzLFxuICAgIH07XG4gICAgdGhpcy5hY2NvdW50ID0gcHJvcHMuYWNjb3VudDtcbiAgICB0aGlzLnJlZ2lvbiA9IHByb3BzLnJlZ2lvbjtcbiAgICB0aGlzLnBhcnRpdGlvbiA9IHByb3BzLnBhcnRpdGlvbjtcbiAgICB0aGlzLnVybFN1ZmZpeCA9IHByb3BzLnVybFN1ZmZpeDtcbiAgICB0aGlzLnNkayA9IHByb3BzLnNkaztcblxuICAgIC8vIFdlIG5lZWQgbmFtZXMgb2YgbmVzdGVkIHN0YWNrIHNvIHdlIGNhbiBldmFsdWF0ZSBjcm9zcyBzdGFjayByZWZlcmVuY2VzXG4gICAgdGhpcy5uZXN0ZWRTdGFja05hbWVzID0gcHJvcHMubmVzdGVkU3RhY2tOYW1lcyA/PyB7fTtcblxuICAgIC8vIFRoZSBjdXJyZW50IHJlc291cmNlcyBvZiB0aGUgU3RhY2suXG4gICAgLy8gV2UgbmVlZCB0aGVtIHRvIGZpZ3VyZSBvdXQgdGhlIHBoeXNpY2FsIG5hbWUgb2YgYSByZXNvdXJjZSBpbiBjYXNlIGl0IHdhc24ndCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIuXG4gICAgLy8gV2UgZmV0Y2ggaXQgbGF6aWx5LCB0byBzYXZlIGEgc2VydmljZSBjYWxsLCBpbiBjYXNlIGFsbCBob3Rzd2FwcGVkIHJlc291cmNlcyBoYXZlIHRoZWlyIHBoeXNpY2FsIG5hbWVzIHNldC5cbiAgICB0aGlzLnN0YWNrUmVzb3VyY2VzID0gbmV3IExhenlMaXN0U3RhY2tSZXNvdXJjZXModGhpcy5zZGssIHRoaXMuc3RhY2tOYW1lKTtcblxuICAgIC8vIENsb3VkRm9ybWF0aW9uIEV4cG9ydHMgbG9va3VwIHRvIGJlIGFibGUgdG8gcmVzb2x2ZSBGbjo6SW1wb3J0VmFsdWUgaW50cmluc2ljcyBpbiB0ZW1wbGF0ZVxuICAgIHRoaXMubG9va3VwRXhwb3J0ID0gbmV3IExhenlMb29rdXBFeHBvcnQodGhpcy5zZGspO1xuICB9XG5cbiAgLy8gY2xvbmVzIGN1cnJlbnQgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlIG9iamVjdCwgYnV0IHVwZGF0ZXMgdGhlIHN0YWNrIG5hbWVcbiAgcHVibGljIGFzeW5jIGNyZWF0ZU5lc3RlZEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZShcbiAgICBzdGFja05hbWU6IHN0cmluZyxcbiAgICBuZXN0ZWRUZW1wbGF0ZTogVGVtcGxhdGUsXG4gICAgbmVzdGVkU3RhY2tQYXJhbWV0ZXJzOiB7IFtwYXJhbWV0ZXJOYW1lOiBzdHJpbmddOiBhbnkgfSxcbiAgKSB7XG4gICAgY29uc3QgZXZhbHVhdGVkUGFyYW1zID0gYXdhaXQgdGhpcy5ldmFsdWF0ZUNmbkV4cHJlc3Npb24obmVzdGVkU3RhY2tQYXJhbWV0ZXJzKTtcbiAgICByZXR1cm4gbmV3IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSh7XG4gICAgICBzdGFja05hbWUsXG4gICAgICB0ZW1wbGF0ZTogbmVzdGVkVGVtcGxhdGUsXG4gICAgICBwYXJhbWV0ZXJzOiBldmFsdWF0ZWRQYXJhbXMsXG4gICAgICBhY2NvdW50OiB0aGlzLmFjY291bnQsXG4gICAgICByZWdpb246IHRoaXMucmVnaW9uLFxuICAgICAgcGFydGl0aW9uOiB0aGlzLnBhcnRpdGlvbixcbiAgICAgIHVybFN1ZmZpeDogdGhpcy51cmxTdWZmaXgsXG4gICAgICBzZGs6IHRoaXMuc2RrLFxuICAgICAgbmVzdGVkU3RhY2tOYW1lczogdGhpcy5uZXN0ZWRTdGFja05hbWVzLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGVzdGFibGlzaFJlc291cmNlUGh5c2ljYWxOYW1lKGxvZ2ljYWxJZDogc3RyaW5nLCBwaHlzaWNhbE5hbWVJbkNmblRlbXBsYXRlOiBhbnkpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmIChwaHlzaWNhbE5hbWVJbkNmblRlbXBsYXRlICE9IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihwaHlzaWNhbE5hbWVJbkNmblRlbXBsYXRlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgZXZhbHVhdGUgdGhlIHJlc291cmNlJ3MgbmFtZSBDbG91ZEZvcm1hdGlvbiBleHByZXNzaW9uLFxuICAgICAgICAvLyBqdXN0IGxvb2sgaXQgdXAgaW4gdGhlIGN1cnJlbnRseSBkZXBsb3llZCBTdGFja1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgQ2ZuRXZhbHVhdGlvbkV4Y2VwdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmRQaHlzaWNhbE5hbWVGb3IobG9naWNhbElkKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBmaW5kUGh5c2ljYWxOYW1lRm9yKGxvZ2ljYWxJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBzdGFja1Jlc291cmNlcyA9IGF3YWl0IHRoaXMuc3RhY2tSZXNvdXJjZXMubGlzdFN0YWNrUmVzb3VyY2VzKCk7XG4gICAgcmV0dXJuIHN0YWNrUmVzb3VyY2VzLmZpbmQoc3IgPT4gc3IuTG9naWNhbFJlc291cmNlSWQgPT09IGxvZ2ljYWxJZCk/LlBoeXNpY2FsUmVzb3VyY2VJZDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBmaW5kTG9naWNhbElkRm9yUGh5c2ljYWxOYW1lKHBoeXNpY2FsTmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBzdGFja1Jlc291cmNlcyA9IGF3YWl0IHRoaXMuc3RhY2tSZXNvdXJjZXMubGlzdFN0YWNrUmVzb3VyY2VzKCk7XG4gICAgcmV0dXJuIHN0YWNrUmVzb3VyY2VzLmZpbmQoc3IgPT4gc3IuUGh5c2ljYWxSZXNvdXJjZUlkID09PSBwaHlzaWNhbE5hbWUpPy5Mb2dpY2FsUmVzb3VyY2VJZDtcbiAgfVxuXG4gIHB1YmxpYyBmaW5kUmVmZXJlbmNlc1RvKGxvZ2ljYWxJZDogc3RyaW5nKTogQXJyYXk8UmVzb3VyY2VEZWZpbml0aW9uPiB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEFycmF5PFJlc291cmNlRGVmaW5pdGlvbj4oKTtcbiAgICBmb3IgKGNvbnN0IFtyZXNvdXJjZUxvZ2ljYWxJZCwgcmVzb3VyY2VEZWZdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMudGVtcGxhdGU/LlJlc291cmNlcyA/PyB7fSkpIHtcbiAgICAgIGlmIChsb2dpY2FsSWQgIT09IHJlc291cmNlTG9naWNhbElkICYmIHRoaXMucmVmZXJlbmNlcyhsb2dpY2FsSWQsIHJlc291cmNlRGVmKSkge1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgLi4uKHJlc291cmNlRGVmIGFzIGFueSksXG4gICAgICAgICAgTG9naWNhbElkOiByZXNvdXJjZUxvZ2ljYWxJZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZXZhbHVhdGVDZm5FeHByZXNzaW9uKGNmbkV4cHJlc3Npb246IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIENsb3VkRm9ybWF0aW9uIGludHJpbnNpYyBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBzdXBwb3J0ZWQgaW50cmluc2ljIGZ1bmN0aW9ucyBhcmUgZG9jdW1lbnRlZCBpbiBSRUFETUUubWQgLS0gcGxlYXNlIHVwZGF0ZVxuICAgICAqIGxpc3Qgb2Ygc3VwcG9ydGVkIGZ1bmN0aW9ucyB3aGVuIGFkZGluZyBuZXcgZXZhbHVhdGlvbnNcbiAgICAgKlxuICAgICAqIFNlZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvaW50cmluc2ljLWZ1bmN0aW9uLXJlZmVyZW5jZS5odG1sXG4gICAgICovXG4gICAgY2xhc3MgQ2ZuSW50cmluc2ljcyB7XG4gICAgICBwdWJsaWMgZXZhbHVhdGVJbnRyaW5zaWMoaW50cmluc2ljOiBJbnRyaW5zaWMpOiBhbnkge1xuICAgICAgICBjb25zdCBpbnRyaW5zaWNGdW5jID0gKHRoaXMgYXMgYW55KVtpbnRyaW5zaWMubmFtZV07XG4gICAgICAgIGlmICghaW50cmluc2ljRnVuYykge1xuICAgICAgICAgIHRocm93IG5ldyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKGBDbG91ZEZvcm1hdGlvbiBmdW5jdGlvbiAke2ludHJpbnNpYy5uYW1lfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcmdzQXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW50cmluc2ljLmFyZ3MpID8gaW50cmluc2ljLmFyZ3MgOiBbaW50cmluc2ljLmFyZ3NdO1xuXG4gICAgICAgIHJldHVybiBpbnRyaW5zaWNGdW5jLmFwcGx5KHRoaXMsIGFyZ3NBc0FycmF5KTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ0ZuOjpKb2luJyhzZXBhcmF0b3I6IHN0cmluZywgYXJnczogYW55W10pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBldmFsdWF0ZWRBcmdzID0gYXdhaXQgc2VsZi5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oYXJncyk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZWRBcmdzLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ0ZuOjpTcGxpdCcoc2VwYXJhdG9yOiBzdHJpbmcsIGFyZ3M6IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGV2YWx1YXRlZEFyZ3MgPSBhd2FpdCBzZWxmLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihhcmdzKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZEFyZ3Muc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ0ZuOjpTZWxlY3QnKGluZGV4OiBudW1iZXIsIGFyZ3M6IGFueVtdKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZXZhbHVhdGVkQXJncyA9IGF3YWl0IHNlbGYuZXZhbHVhdGVDZm5FeHByZXNzaW9uKGFyZ3MpO1xuICAgICAgICByZXR1cm4gZXZhbHVhdGVkQXJnc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGFzeW5jICdSZWYnKGxvZ2ljYWxJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcmVmVGFyZ2V0ID0gYXdhaXQgc2VsZi5maW5kUmVmVGFyZ2V0KGxvZ2ljYWxJZCk7XG4gICAgICAgIGlmIChyZWZUYXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gcmVmVGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKGBQYXJhbWV0ZXIgb3IgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgY291bGQgbm90IGJlIGZvdW5kIGZvciBldmFsdWF0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ0ZuOjpHZXRBdHQnKGxvZ2ljYWxJZDogc3RyaW5nLCBhdHRyaWJ1dGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICAvLyBUb0RvIGhhbmRsZSB0aGUgJ2xvZ2ljYWxJZC5hdHRyaWJ1dGVOYW1lJyBmb3JtIG9mIEZuOjpHZXRBdHRcbiAgICAgICAgY29uc3QgYXR0clZhbHVlID0gYXdhaXQgc2VsZi5maW5kR2V0QXR0VGFyZ2V0KGxvZ2ljYWxJZCwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGlmIChhdHRyVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYXR0clZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKGBBdHRyaWJ1dGUgJyR7YXR0cmlidXRlTmFtZX0nIG9mIHJlc291cmNlICcke2xvZ2ljYWxJZH0nIGNvdWxkIG5vdCBiZSBmb3VuZCBmb3IgZXZhbHVhdGlvbmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFzeW5jICdGbjo6U3ViJyh0ZW1wbGF0ZTogc3RyaW5nLCBleHBsaWNpdFBsYWNlaG9sZGVycz86IHsgW3ZhcmlhYmxlOiBzdHJpbmddOiBzdHJpbmcgfSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IGV4cGxpY2l0UGxhY2Vob2xkZXJzXG4gICAgICAgICAgPyBhd2FpdCBzZWxmLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihleHBsaWNpdFBsYWNlaG9sZGVycylcbiAgICAgICAgICA6IHt9O1xuXG4gICAgICAgIHJldHVybiBhc3luY0dsb2JhbFJlcGxhY2UodGVtcGxhdGUsIC9cXCR7KFtefV0qKX0vZywga2V5ID0+IHtcbiAgICAgICAgICBpZiAoa2V5IGluIHBsYWNlaG9sZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyc1trZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzcGxpdEtleSA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgcmV0dXJuIHNwbGl0S2V5Lmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICA/IHRoaXMuUmVmKGtleSlcbiAgICAgICAgICAgICAgOiB0aGlzWydGbjo6R2V0QXR0J10oc3BsaXRLZXlbMF0sIHNwbGl0S2V5LnNsaWNlKDEpLmpvaW4oJy4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ0ZuOjpJbXBvcnRWYWx1ZScobmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZXhwb3J0ZWQgPSBhd2FpdCBzZWxmLmxvb2t1cEV4cG9ydC5sb29rdXBFeHBvcnQobmFtZSk7XG4gICAgICAgIGlmICghZXhwb3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ2ZuRXZhbHVhdGlvbkV4Y2VwdGlvbihgRXhwb3J0ICcke25hbWV9JyBjb3VsZCBub3QgYmUgZm91bmQgZm9yIGV2YWx1YXRpb25gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4cG9ydGVkLlZhbHVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYEV4cG9ydCAnJHtuYW1lfScgZXhpc3RzIHdpdGhvdXQgYSB2YWx1ZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBvcnRlZC5WYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ZuRXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2ZuRXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjZm5FeHByZXNzaW9uKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNmbkV4cHJlc3Npb24ubWFwKGV4cHIgPT4gdGhpcy5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oZXhwcikpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNmbkV4cHJlc3Npb24gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBpbnRyaW5zaWMgPSB0aGlzLnBhcnNlSW50cmluc2ljKGNmbkV4cHJlc3Npb24pO1xuICAgICAgaWYgKGludHJpbnNpYykge1xuICAgICAgICByZXR1cm4gbmV3IENmbkludHJpbnNpY3MoKS5ldmFsdWF0ZUludHJpbnNpYyhpbnRyaW5zaWMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmV0OiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhjZm5FeHByZXNzaW9uKSkge1xuICAgICAgICAgIHJldFtrZXldID0gYXdhaXQgdGhpcy5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjZm5FeHByZXNzaW9uO1xuICB9XG5cbiAgcHJpdmF0ZSByZWZlcmVuY2VzKGxvZ2ljYWxJZDogc3RyaW5nLCB0ZW1wbGF0ZUVsZW1lbnQ6IGFueSk6IGJvb2xlYW4ge1xuICAgIGlmICh0eXBlb2YgdGVtcGxhdGVFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGxvZ2ljYWxJZCA9PT0gdGVtcGxhdGVFbGVtZW50O1xuICAgIH1cblxuICAgIGlmICh0ZW1wbGF0ZUVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRlbXBsYXRlRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZUVsZW1lbnQuc29tZShlbCA9PiB0aGlzLnJlZmVyZW5jZXMobG9naWNhbElkLCBlbCkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGVtcGxhdGVFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGVtcGxhdGVFbGVtZW50KS5zb21lKGVsID0+IHRoaXMucmVmZXJlbmNlcyhsb2dpY2FsSWQsIGVsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUludHJpbnNpYyh4OiBhbnkpOiBJbnRyaW5zaWMgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh4KTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYgKGtleXNbMF0uc3RhcnRzV2l0aCgnRm46OicpIHx8IGtleXNbMF0gPT09ICdSZWYnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZToga2V5c1swXSxcbiAgICAgICAgYXJnczogeFtrZXlzWzBdXSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZpbmRSZWZUYXJnZXQobG9naWNhbElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIC8vIGZpcnN0LCBjaGVjayB0byBzZWUgaWYgdGhlIFJlZiBpcyBhIFBhcmFtZXRlciB3aG8ncyB2YWx1ZSB3ZSBoYXZlXG4gICAgaWYgKGxvZ2ljYWxJZCA9PT0gJ0FXUzo6VVJMU3VmZml4Jykge1xuICAgICAgaWYgKCF0aGlzLmNhY2hlZFVybFN1ZmZpeCkge1xuICAgICAgICB0aGlzLmNhY2hlZFVybFN1ZmZpeCA9IHRoaXMudXJsU3VmZml4KHRoaXMucmVnaW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkVXJsU3VmZml4O1xuICAgIH1cblxuICAgIC8vIFRyeSBmaW5kaW5nIHRoZSByZWYgaW4gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzXG4gICAgY29uc3QgcGFyYW1ldGVyVGFyZ2V0ID0gdGhpcy5jb250ZXh0W2xvZ2ljYWxJZF07XG4gICAgaWYgKHBhcmFtZXRlclRhcmdldCkge1xuICAgICAgcmV0dXJuIHBhcmFtZXRlclRhcmdldDtcbiAgICB9XG5cbiAgICAvLyBJZiBub3QgaW4gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLCBzZWUgaWYgdGhlcmUgaXMgYSBkZWZhdWx0IHZhbHVlIGluIHRoZSB0ZW1wbGF0ZSBwYXJhbWV0ZXIgdGhhdCB3YXMgbm90IHBhc3NlZCBpblxuICAgIGNvbnN0IGRlZmF1bHRQYXJhbWV0ZXJWYWx1ZSA9IHRoaXMudGVtcGxhdGUuUGFyYW1ldGVycz8uW2xvZ2ljYWxJZF0/LkRlZmF1bHQ7XG4gICAgaWYgKGRlZmF1bHRQYXJhbWV0ZXJWYWx1ZSkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbWV0ZXJWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIG5vdCBhIFBhcmFtZXRlciwgd2UgbmVlZCB0byBzZWFyY2ggaW4gdGhlIGN1cnJlbnQgU3RhY2sgcmVzb3VyY2VzXG4gICAgcmV0dXJuIHRoaXMuZmluZEdldEF0dFRhcmdldChsb2dpY2FsSWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmaW5kR2V0QXR0VGFyZ2V0KGxvZ2ljYWxJZDogc3RyaW5nLCBhdHRyaWJ1dGU/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuXG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgdGhlIGF0dHJpYnV0ZSBpcyByZWZlcmVuY2luZyBhIHN0YWNrIG91dHB1dCAodXNlZCBpbiBuZXN0ZWQgc3RhY2tzIHRvIHNoYXJlIHBhcmFtZXRlcnMpXG4gICAgLy8gU2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NDbG91ZEZvcm1hdGlvbi9sYXRlc3QvVXNlckd1aWRlL3F1aWNrcmVmLWNsb3VkZm9ybWF0aW9uLmh0bWwjdzJhYjFjMTdjMjNjMTliNVxuICAgIGlmIChsb2dpY2FsSWQgPT09ICdPdXRwdXRzJyAmJiBhdHRyaWJ1dGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih0aGlzLnRlbXBsYXRlLk91dHB1dHNbYXR0cmlidXRlXT8uVmFsdWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWNrUmVzb3VyY2VzID0gYXdhaXQgdGhpcy5zdGFja1Jlc291cmNlcy5saXN0U3RhY2tSZXNvdXJjZXMoKTtcbiAgICBjb25zdCBmb3VuZFJlc291cmNlID0gc3RhY2tSZXNvdXJjZXMuZmluZChzciA9PiBzci5Mb2dpY2FsUmVzb3VyY2VJZCA9PT0gbG9naWNhbElkKTtcbiAgICBpZiAoIWZvdW5kUmVzb3VyY2UpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kUmVzb3VyY2UuUmVzb3VyY2VUeXBlID09ICdBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjaycgJiYgYXR0cmlidXRlPy5zdGFydHNXaXRoKCdPdXRwdXRzLicpKSB7XG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgYXR0cmlidXRlcyBmcm9tIGFub3RoZXIgc3RhY2sncyBPdXRwdXQgc2VjdGlvblxuICAgICAgY29uc3QgZGVwZW5kYW50U3RhY2tOYW1lID0gdGhpcy5uZXN0ZWRTdGFja05hbWVzW2xvZ2ljYWxJZF0/Lm5lc3RlZFN0YWNrUGh5c2ljYWxOYW1lO1xuICAgICAgaWYgKCFkZXBlbmRhbnRTdGFja05hbWUpIHtcbiAgICAgICAgLy90aGlzIGlzIGEgbmV3bHkgY3JlYXRlZCBuZXN0ZWQgc3RhY2sgYW5kIGNhbm5vdCBiZSBob3Rzd2FwcGVkXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXBlbmRhbnRTdGFja1RlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5SZXNvdXJjZXNbbG9naWNhbElkXTtcbiAgICAgIGNvbnN0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUgPSBhd2FpdCB0aGlzLmNyZWF0ZU5lc3RlZEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZShcbiAgICAgICAgZGVwZW5kYW50U3RhY2tOYW1lLFxuICAgICAgICBkZXBlbmRhbnRTdGFja1RlbXBsYXRlPy5Qcm9wZXJ0aWVzPy5OZXN0ZWRUZW1wbGF0ZSxcbiAgICAgICAgZGVwZW5kYW50U3RhY2tUZW1wbGF0ZS5uZXdWYWx1ZT8uUHJvcGVydGllcz8uUGFyYW1ldGVycyk7XG5cbiAgICAgIC8vIFNwbGl0IE91dHB1dHMuPHJlZk5hbWU+IGludG8gJ091dHB1dHMnIGFuZCAnPHJlZk5hbWU+JyBhbmQgcmVjdXJzaXZlbHkgY2FsbCBldmFsdWF0ZVxuICAgICAgcmV0dXJuIGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHsgJ0ZuOjpHZXRBdHQnOiBhdHRyaWJ1dGUuc3BsaXQoL1xcLiguKikvcykgfSk7XG4gICAgfVxuICAgIC8vIG5vdywgd2UgbmVlZCB0byBmb3JtYXQgdGhlIGFwcHJvcHJpYXRlIGlkZW50aWZpZXIgZGVwZW5kaW5nIG9uIHRoZSByZXNvdXJjZSB0eXBlLFxuICAgIC8vIGFuZCB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZSBuYW1lXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzb3VyY2VBdHRyaWJ1dGUoZm91bmRSZXNvdXJjZSwgYXR0cmlidXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0UmVzb3VyY2VBdHRyaWJ1dGUocmVzb3VyY2U6IEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeSwgYXR0cmlidXRlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBoeXNpY2FsSWQgPSByZXNvdXJjZS5QaHlzaWNhbFJlc291cmNlSWQ7XG5cbiAgICAvLyBubyBhdHRyaWJ1dGUgbWVhbnMgUmVmIGV4cHJlc3Npb24sIGZvciB3aGljaCB3ZSB1c2UgdGhlIHBoeXNpY2FsIElEIGRpcmVjdGx5XG4gICAgaWYgKCFhdHRyaWJ1dGUpIHtcbiAgICAgIHJldHVybiBwaHlzaWNhbElkO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc291cmNlVHlwZUZvcm1hdHMgPSBSRVNPVVJDRV9UWVBFX0FUVFJJQlVURVNfRk9STUFUU1tyZXNvdXJjZS5SZXNvdXJjZVR5cGVdO1xuICAgIGlmICghcmVzb3VyY2VUeXBlRm9ybWF0cykge1xuICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYFdlIGRvbid0IHN1cHBvcnQgYXR0cmlidXRlcyBvZiB0aGUgJyR7cmVzb3VyY2UuUmVzb3VyY2VUeXBlfScgcmVzb3VyY2UuIFRoaXMgaXMgYSBDREsgbGltaXRhdGlvbi4gYCArXG4gICAgICAgICdQbGVhc2UgcmVwb3J0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvbmV3L2Nob29zZScpO1xuICAgIH1cbiAgICBjb25zdCBhdHRyaWJ1dGVGbXRGdW5jID0gcmVzb3VyY2VUeXBlRm9ybWF0c1thdHRyaWJ1dGVdO1xuICAgIGlmICghYXR0cmlidXRlRm10RnVuYykge1xuICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYFdlIGRvbid0IHN1cHBvcnQgdGhlICcke2F0dHJpYnV0ZX0nIGF0dHJpYnV0ZSBvZiB0aGUgJyR7cmVzb3VyY2UuUmVzb3VyY2VUeXBlfScgcmVzb3VyY2UuIFRoaXMgaXMgYSBDREsgbGltaXRhdGlvbi4gYCArXG4gICAgICAgICdQbGVhc2UgcmVwb3J0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvbmV3L2Nob29zZScpO1xuICAgIH1cbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcy5nZXRTZXJ2aWNlT2ZSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgY29uc3QgcmVzb3VyY2VUeXBlQXJuUGFydCA9IHRoaXMuZ2V0UmVzb3VyY2VUeXBlQXJuUGFydE9mUmVzb3VyY2UocmVzb3VyY2UpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVGbXRGdW5jKHtcbiAgICAgIHBhcnRpdGlvbjogdGhpcy5wYXJ0aXRpb24sXG4gICAgICBzZXJ2aWNlLFxuICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcbiAgICAgIGFjY291bnQ6IHRoaXMuYWNjb3VudCxcbiAgICAgIHJlc291cmNlVHlwZTogcmVzb3VyY2VUeXBlQXJuUGFydCxcbiAgICAgIHJlc291cmNlTmFtZTogcGh5c2ljYWxJZCEsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldFNlcnZpY2VPZlJlc291cmNlKHJlc291cmNlOiBBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2tSZXNvdXJjZVN1bW1hcnkpOiBzdHJpbmcge1xuICAgIHJldHVybiByZXNvdXJjZS5SZXNvdXJjZVR5cGUuc3BsaXQoJzo6JylbMV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmVzb3VyY2VUeXBlQXJuUGFydE9mUmVzb3VyY2UocmVzb3VyY2U6IEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeSk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVzb3VyY2VUeXBlID0gcmVzb3VyY2UuUmVzb3VyY2VUeXBlO1xuICAgIGNvbnN0IHNwZWNpYWxDYXNlUmVzb3VyY2VUeXBlID0gUkVTT1VSQ0VfVFlQRV9TUEVDSUFMX05BTUVTW3Jlc291cmNlVHlwZV0/LnJlc291cmNlVHlwZTtcbiAgICByZXR1cm4gc3BlY2lhbENhc2VSZXNvdXJjZVR5cGVcbiAgICAgID8gc3BlY2lhbENhc2VSZXNvdXJjZVR5cGVcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGRlZmF1bHQgY2FzZVxuICAgICAgOiByZXNvdXJjZVR5cGUuc3BsaXQoJzo6JylbMl0udG9Mb3dlckNhc2UoKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBUZW1wbGF0ZSA9IHsgW3NlY3Rpb246IHN0cmluZ106IHsgW2hlYWRpbmdzOiBzdHJpbmddOiBhbnkgfSB9O1xuXG5pbnRlcmZhY2UgQXJuUGFydHMge1xuICByZWFkb25seSBwYXJ0aXRpb246IHN0cmluZztcbiAgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuICByZWFkb25seSByZWdpb246IHN0cmluZztcbiAgcmVhZG9ubHkgYWNjb3VudDogc3RyaW5nO1xuICByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcmVzb3VyY2VOYW1lOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVXN1YWxseSwgd2UgZGVkdWNlIHRoZSBuYW1lcyBvZiB0aGUgc2VydmljZSBhbmQgdGhlIHJlc291cmNlIHR5cGUgdXNlZCB0byBmb3JtYXQgdGhlIEFSTiBmcm9tIHRoZSBDbG91ZEZvcm1hdGlvbiByZXNvdXJjZSB0eXBlLlxuICogRm9yIGEgQ0ZOIHR5cGUgbGlrZSBBV1M6OlNlcnZpY2U6OlJlc291cmNlVHlwZSwgdGhlIHNlY29uZCBzZWdtZW50IGJlY29tZXMgdGhlIHNlcnZpY2UgbmFtZSwgYW5kIHRoZSB0aGlyZCB0aGUgcmVzb3VyY2UgdHlwZVxuICogKGFmdGVyIGNvbnZlcnRpbmcgYm90aCBvZiB0aGVtIHRvIGxvd2VyY2FzZSkuXG4gKiBIb3dldmVyLCBzb21lIHJlc291cmNlIHR5cGVzIGJyZWFrIHRoaXMgc2ltcGxlIGNvbnZlbnRpb24sIGFuZCB3ZSBuZWVkIHRvIHNwZWNpYWwtY2FzZSB0aGVtLlxuICogVGhpcyBtYXAgaXMgZm9yIHN0b3JpbmcgdGhvc2UgY2FzZXMuXG4gKi9cbmNvbnN0IFJFU09VUkNFX1RZUEVfU1BFQ0lBTF9OQU1FUzogeyBbdHlwZTogc3RyaW5nXTogeyByZXNvdXJjZVR5cGU6IHN0cmluZyB9IH0gPSB7XG4gICdBV1M6OkV2ZW50czo6RXZlbnRCdXMnOiB7XG4gICAgcmVzb3VyY2VUeXBlOiAnZXZlbnQtYnVzJyxcbiAgfSxcbn07XG5cbmNvbnN0IFJFU09VUkNFX1RZUEVfQVRUUklCVVRFU19GT1JNQVRTOiB7IFt0eXBlOiBzdHJpbmddOiB7IFthdHRyaWJ1dGU6IHN0cmluZ106IChwYXJ0czogQXJuUGFydHMpID0+IHN0cmluZyB9IH0gPSB7XG4gICdBV1M6OklBTTo6Um9sZSc6IHsgQXJuOiBpYW1Bcm5GbXQgfSxcbiAgJ0FXUzo6SUFNOjpVc2VyJzogeyBBcm46IGlhbUFybkZtdCB9LFxuICAnQVdTOjpJQU06Okdyb3VwJzogeyBBcm46IGlhbUFybkZtdCB9LFxuICAnQVdTOjpTMzo6QnVja2V0JzogeyBBcm46IHMzQXJuRm10IH0sXG4gICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nOiB7IEFybjogc3RkQ29sb25SZXNvdXJjZUFybkZtdCB9LFxuICAnQVdTOjpFdmVudHM6OkV2ZW50QnVzJzoge1xuICAgIEFybjogc3RkU2xhc2hSZXNvdXJjZUFybkZtdCxcbiAgICAvLyB0aGUgbmFtZSBhdHRyaWJ1dGUgb2YgdGhlIEV2ZW50QnVzIGlzIHRoZSBzYW1lIGFzIHRoZSBSZWZcbiAgICBOYW1lOiBwYXJ0cyA9PiBwYXJ0cy5yZXNvdXJjZU5hbWUsXG4gIH0sXG4gICdBV1M6OkR5bmFtb0RCOjpUYWJsZSc6IHsgQXJuOiBzdGRTbGFzaFJlc291cmNlQXJuRm10IH0sXG4gICdBV1M6OkFwcFN5bmM6OkdyYXBoUUxBcGknOiB7IEFwaUlkOiBhcHBzeW5jR3JhcGhRbEFwaUFwaUlkRm10IH0sXG4gICdBV1M6OkFwcFN5bmM6OkZ1bmN0aW9uQ29uZmlndXJhdGlvbic6IHsgRnVuY3Rpb25JZDogYXBwc3luY0dyYXBoUWxGdW5jdGlvbklERm10IH0sXG4gICdBV1M6OkFwcFN5bmM6OkRhdGFTb3VyY2UnOiB7IE5hbWU6IGFwcHN5bmNHcmFwaFFsRGF0YVNvdXJjZU5hbWVGbXQgfSxcbn07XG5cbmZ1bmN0aW9uIGlhbUFybkZtdChwYXJ0czogQXJuUGFydHMpOiBzdHJpbmcge1xuICAvLyB3ZSBza2lwIHJlZ2lvbiBmb3IgSUFNIHJlc291cmNlc1xuICByZXR1cm4gYGFybjoke3BhcnRzLnBhcnRpdGlvbn06JHtwYXJ0cy5zZXJ2aWNlfTo6JHtwYXJ0cy5hY2NvdW50fToke3BhcnRzLnJlc291cmNlVHlwZX0vJHtwYXJ0cy5yZXNvdXJjZU5hbWV9YDtcbn1cblxuZnVuY3Rpb24gczNBcm5GbXQocGFydHM6IEFyblBhcnRzKTogc3RyaW5nIHtcbiAgLy8gd2Ugc2tpcCBhY2NvdW50LCByZWdpb24gYW5kIHJlc291cmNlVHlwZSBmb3IgUzMgcmVzb3VyY2VzXG4gIHJldHVybiBgYXJuOiR7cGFydHMucGFydGl0aW9ufToke3BhcnRzLnNlcnZpY2V9Ojo6JHtwYXJ0cy5yZXNvdXJjZU5hbWV9YDtcbn1cblxuZnVuY3Rpb24gc3RkQ29sb25SZXNvdXJjZUFybkZtdChwYXJ0czogQXJuUGFydHMpOiBzdHJpbmcge1xuICAvLyB0aGlzIGlzIGEgc3RhbmRhcmQgZm9ybWF0IGZvciBBUk5zIGxpa2U6IGFybjphd3M6c2VydmljZTpyZWdpb246YWNjb3VudDpyZXNvdXJjZVR5cGU6cmVzb3VyY2VOYW1lXG4gIHJldHVybiBgYXJuOiR7cGFydHMucGFydGl0aW9ufToke3BhcnRzLnNlcnZpY2V9OiR7cGFydHMucmVnaW9ufToke3BhcnRzLmFjY291bnR9OiR7cGFydHMucmVzb3VyY2VUeXBlfToke3BhcnRzLnJlc291cmNlTmFtZX1gO1xufVxuXG5mdW5jdGlvbiBzdGRTbGFzaFJlc291cmNlQXJuRm10KHBhcnRzOiBBcm5QYXJ0cyk6IHN0cmluZyB7XG4gIC8vIHRoaXMgaXMgYSBzdGFuZGFyZCBmb3JtYXQgZm9yIEFSTnMgbGlrZTogYXJuOmF3czpzZXJ2aWNlOnJlZ2lvbjphY2NvdW50OnJlc291cmNlVHlwZS9yZXNvdXJjZU5hbWVcbiAgcmV0dXJuIGBhcm46JHtwYXJ0cy5wYXJ0aXRpb259OiR7cGFydHMuc2VydmljZX06JHtwYXJ0cy5yZWdpb259OiR7cGFydHMuYWNjb3VudH06JHtwYXJ0cy5yZXNvdXJjZVR5cGV9LyR7cGFydHMucmVzb3VyY2VOYW1lfWA7XG59XG5cbmZ1bmN0aW9uIGFwcHN5bmNHcmFwaFFsQXBpQXBpSWRGbXQocGFydHM6IEFyblBhcnRzKTogc3RyaW5nIHtcbiAgLy8gYXJuOmF3czphcHBzeW5jOnVzLWVhc3QtMToxMTExMTExMTExMTE6YXBpcy88YXBpSWQ+XG4gIHJldHVybiBwYXJ0cy5yZXNvdXJjZU5hbWUuc3BsaXQoJy8nKVsxXTtcbn1cblxuZnVuY3Rpb24gYXBwc3luY0dyYXBoUWxGdW5jdGlvbklERm10KHBhcnRzOiBBcm5QYXJ0cyk6IHN0cmluZyB7XG4gIC8vIGFybjphd3M6YXBwc3luYzp1cy1lYXN0LTE6MTExMTExMTExMTExOmFwaXMvPGFwaUlkPi9mdW5jdGlvbnMvPGZ1bmN0aW9uSWQ+XG4gIHJldHVybiBwYXJ0cy5yZXNvdXJjZU5hbWUuc3BsaXQoJy8nKVszXTtcbn1cblxuZnVuY3Rpb24gYXBwc3luY0dyYXBoUWxEYXRhU291cmNlTmFtZUZtdChwYXJ0czogQXJuUGFydHMpOiBzdHJpbmcge1xuICAvLyBhcm46YXdzOmFwcHN5bmM6dXMtZWFzdC0xOjExMTExMTExMTExMTphcGlzLzxhcGlJZD4vZGF0YXNvdXJjZXMvPG5hbWU+XG4gIHJldHVybiBwYXJ0cy5yZXNvdXJjZU5hbWUuc3BsaXQoJy8nKVszXTtcbn1cblxuaW50ZXJmYWNlIEludHJpbnNpYyB7XG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgYXJnczogYW55O1xufVxuXG5hc3luYyBmdW5jdGlvbiBhc3luY0dsb2JhbFJlcGxhY2Uoc3RyOiBzdHJpbmcsIHJlZ2V4OiBSZWdFeHAsIGNiOiAoeDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAoIXJlZ2V4Lmdsb2JhbCkgeyB0aHJvdyBuZXcgRXJyb3IoJ1JlZ2V4IG11c3QgYmUgY3JlYXRlZCB3aXRoIC9nIGZsYWcnKTsgfVxuXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBzdGFydCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaCkgeyBicmVhazsgfVxuXG4gICAgcmV0LnB1c2goc3RyLnN1YnN0cmluZyhzdGFydCwgbWF0Y2guaW5kZXgpKTtcbiAgICByZXQucHVzaChhd2FpdCBjYihtYXRjaFsxXSkpO1xuXG4gICAgc3RhcnQgPSByZWdleC5sYXN0SW5kZXg7XG4gIH1cbiAgcmV0LnB1c2goc3RyLnNsaWNlKHN0YXJ0KSk7XG5cbiAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn1cbiJdfQ==